import NeuQuant from './NeuQuant';
import LZWEncoder from './LZWEncoder';

const GIFEncoder = function GIFEncoder() {

    for (var i = 0, chr = {}; i < 256; i++) {
        chr[i] = String.fromCharCode(i);
    }

    function ByteArray() {
        this.bin = [];
    }

    ByteArray.prototype.getData = function () {
        for (var v = '', l = this.bin.length, i = 0; i < l; i++)
            v += chr[this.bin[i]];
        return v;
    };

    ByteArray.prototype.writeByte = function (val) {
        this.bin.push(val);
    };

    ByteArray.prototype.writeUTFBytes = function (string) {
        const l = string.length;
        let i = 0;
        for (; i < l; i++) {
            this.writeByte(string.charCodeAt(i));
        }
    };

    ByteArray.prototype.writeBytes = function (array, offset, length) {
        const l = length || array.length;
        let i = offset || 0;
        for (; i < l; i++)
            this.writeByte(array[i]);
    };

    let width; // image size
    let height;
    let transparent = null; // transparent color if given
    let transIndex; // transparent index in color table
    let repeat = -1; // no repeat
    let delay = 0; // frame delay (hundredths)
    let started = false; // ready to output frames
    let out;
    let image; // current frame
    let pixels; // BGR byte array from frame
    let indexedPixels; // converted frame indexed to palette
    let colorDepth; // number of bit planes
    let colorTab; // RGB palette
    let usedEntry = []; // active palette entries
    let palSize = 7; // color table size (bits-1)
    let dispose = -1; // disposal code (-1 = use default)
    let closeStream = false; // close stream when finished
    let firstFrame = true;
    let sizeSet = false; // if false, get size from first frame
    let sample = 10; // default sample interval for quantizer
    let comment = 'Generated by jsgif (https://github.com/antimatter15/jsgif/)'; // default comment for generated gif


    const setDispose = function setDispose(code) {
        if (code >= 0) dispose = code;
    };

    const setDelay = function setDelay(ms) {
        delay = Math.round(ms / 10);
    };

    const setRepeat = function setRepeat(iter) {
        if (iter >= 0) repeat = iter;
    };

    const setTransparent = function setTransparent(c) {
        transparent = c;
    };

    const setComment = function setComment(c) {
        comment = c;
    };


    const addFrame = function addFrame(im, is_imageData) {

        if ((im === null) || !started || out === null) {
            throw new Error('Please call start method before calling addFrame');
        }

        let ok = true;

        try {
            if (!is_imageData) {
                image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;
                if (!sizeSet) setSize(im.canvas.width, im.canvas.height);
            } else {
                if (im instanceof ImageData) {
                    image = im.data;
                    if (!sizeSet || width !== im.width || height !== im.height) {
                        setSize(im.width, im.height);
                    } else {

                    }
                } else if (im instanceof Uint8ClampedArray) {
                    if (im.length === (width * height * 4)) {
                        image = im;
                    } else {
                        console.log('Please set the correct size: ImageData length mismatch');
                        ok = false;
                    }
                } else {
                    console.log('Please provide correct input');
                    ok = false;
                }
            }
            getImagePixels(); // convert to correct format if necessary
            analyzePixels(); // build color table & map pixels

            if (firstFrame) {
                writeLSD(); // logical screen descriptior
                writePalette(); // global color table
                if (repeat >= 0) {
                    // use NS app extension to indicate reps
                    writeNetscapeExt();
                }
            }

            writeGraphicCtrlExt(); // write graphic control extension
            if (comment !== '') {
                writeCommentExt(); // write comment extension
            }
            writeImageDesc(); // image descriptor
            if (!firstFrame) writePalette(); // local color table
            writePixels(); // encode and write pixel data
            firstFrame = false;
        } catch (e) {
            ok = false;
        }

        return ok;
    };

    const download = function download(filename) {
        if (out === null || closeStream === false) {
            console.log('Please call start method and add frames and call finish method before calling download');
        } else {
            filename = filename !== undefined ? (filename.endsWith('.gif') ? filename : filename + '.gif') : 'download.gif';
            const templink = document.createElement('a');
            templink.download = filename;
            templink.href = URL.createObjectURL(new Blob([new Uint8Array(out.bin)], {type: 'image/gif'}));
            templink.click();
        }
    };

    const finish = function finish() {

        if (!started) return false;

        let ok = true;
        started = false;

        try {
            out.writeByte(0x3b); // gif trailer
            closeStream = true;
        } catch (e) {
            ok = false;
        }

        return ok;
    };

    const reset = function reset() {

        // reset for subsequent use
        transIndex = 0;
        image = null;
        pixels = null;
        indexedPixels = null;
        colorTab = null;
        closeStream = false;
        firstFrame = true;
    };

    const setFrameRate = function setFrameRate(fps) {
        if (fps != 0xf) delay = Math.round(100 / fps);
    };

    const setQuality = function setQuality(quality) {
        if (quality < 1) quality = 1;
        sample = quality;
    };

    const setSize = function setSize(w, h) {

        if (started && !firstFrame) return;
        width = w;
        height = h;
        if (width < 1) width = 320;
        if (height < 1) height = 240;
        sizeSet = true;
    };

    const start = function start() {

        reset();
        let ok = true;
        closeStream = false;
        out = new ByteArray();
        try {
            out.writeUTFBytes('GIF89a'); // header
        } catch (e) {
            ok = false;
        }

        return started = ok;
    };

    const cont = function cont() {

        reset();
        const ok = true;
        closeStream = false;
        out = new ByteArray();

        return started = ok;
    };

    const analyzePixels = function analyzePixels() {

        const len = pixels.length;
        const nPix = len / 3;
        indexedPixels = [];
        const nq = new NeuQuant(pixels, len, sample);

        // initialize quantizer
        colorTab = nq.process(); // create reduced palette

        // map image pixels to new palette
        let k = 0;
        for (let j = 0; j < nPix; j++) {
            const index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
            usedEntry[index] = true;
            indexedPixels[j] = index;
        }

        pixels = null;
        colorDepth = 8;
        palSize = 7;

        // get closest match to transparent color if specified
        if (transparent !== null) {
            transIndex = findClosest(transparent);
        }
    };

    const findClosest = function findClosest(c) {

        if (colorTab === null) return -1;
        const r = (c & 0xFF0000) >> 16;
        const g = (c & 0x00FF00) >> 8;
        const b = (c & 0x0000FF);
        let minpos = 0;
        let dmin = 256 * 256 * 256;
        const len = colorTab.length;

        for (let i = 0; i < len;) {
            const dr = r - (colorTab[i++] & 0xff);
            const dg = g - (colorTab[i++] & 0xff);
            const db = b - (colorTab[i] & 0xff);
            const d = dr * dr + dg * dg + db * db;
            const index = i / 3;
            if (usedEntry[index] && (d < dmin)) {
                dmin = d;
                minpos = index;
            }
            i++;
        }
        return minpos;
    };

    const getImagePixels = function getImagePixels() {
        const w = width;
        const h = height;
        pixels = [];
        const data = image;
        let count = 0;

        for (let i = 0; i < h; i++) {

            for (let j = 0; j < w; j++) {

                const b = (i * w * 4) + j * 4;
                pixels[count++] = data[b];
                pixels[count++] = data[b + 1];
                pixels[count++] = data[b + 2];

            }

        }
    };

    const writeGraphicCtrlExt = function writeGraphicCtrlExt() {
        out.writeByte(0x21); // extension introducer
        out.writeByte(0xf9); // GCE label
        out.writeByte(4); // data block size
        let transp;
        let disp;
        if (transparent === null) {
            transp = 0;
            disp = 0; // dispose = no action
        } else {
            transp = 1;
            disp = 2; // force clear if using transparent color
        }
        if (dispose >= 0) {
            disp = dispose & 7; // user override
        }
        disp <<= 2;
        // packed fields
        out.writeByte(0 | // 1:3 reserved
            disp | // 4:6 disposal
            0 | // 7 user input - 0 = none
            transp); // 8 transparency flag

        WriteShort(delay); // delay x 1/100 sec
        out.writeByte(transIndex); // transparent color index
        out.writeByte(0); // block terminator
    };

    const writeCommentExt = function writeCommentExt() {
        out.writeByte(0x21); // extension introducer
        out.writeByte(0xfe); // comment label
        out.writeByte(comment.length); // Block Size (s)
        out.writeUTFBytes(comment);
        out.writeByte(0); // block terminator
    };

    const writeImageDesc = function writeImageDesc() {

        out.writeByte(0x2c); // image separator
        WriteShort(0); // image position x,y = 0,0
        WriteShort(0);
        WriteShort(width); // image size
        WriteShort(height);

        // packed fields
        if (firstFrame) {
            // no LCT - GCT is used for first (or only) frame
            out.writeByte(0);
        } else {
            // specify normal LCT
            out.writeByte(0x80 | // 1 local color table 1=yes
                0 | // 2 interlace - 0=no
                0 | // 3 sorted - 0=no
                0 | // 4-5 reserved
                palSize); // 6-8 size of color table
        }
    };

    const writeLSD = function writeLSD() {

        // logical screen size
        WriteShort(width);
        WriteShort(height);
        // packed fields
        out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)
            0x70 | // 2-4 : color resolution = 7
            0x00 | // 5 : gct sort flag = 0
            palSize)); // 6-8 : gct size

        out.writeByte(0); // background color index
        out.writeByte(0); // pixel aspect ratio - assume 1:1
    };

    const writeNetscapeExt = function writeNetscapeExt() {
        out.writeByte(0x21); // extension introducer
        out.writeByte(0xff); // app extension label
        out.writeByte(11); // block size
        out.writeUTFBytes('NETSCAPE 2.0'); // app id + auth code
        out.writeByte(3); // sub-block size
        out.writeByte(1); // loop sub-block id
        WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)
        out.writeByte(0); // block terminator
    };

    const writePalette = function writePalette() {
        out.writeBytes(colorTab);
        const n = (3 * 256) - colorTab.length;
        for (let i = 0; i < n; i++) out.writeByte(0);
    };

    const WriteShort = function WriteShort(pValue) {
        out.writeByte(pValue & 0xFF);
        out.writeByte((pValue >> 8) & 0xFF);
    };

    const writePixels = function writePixels() {
        const myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);
        myencoder.encode(out);
    };

    const stream = function stream() {
        return out;
    };

    const setProperties = function setProperties(has_start, is_first) {
        started = has_start;
        firstFrame = is_first;
    };

};

export default new GIFEncoder();
